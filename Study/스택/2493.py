# 2493

N = int(input())
heights = list(map(int,input().split()))
stack = []
# 초기값 설정
answer = [0] * N

for i in range(N):
    # 문제 풀이 방법
    # 스택이 비어있으면 넣어줘야한다
    # 스택이 비어있지 않으면 빼줘야 한다
    
    # 스택은 현재의 타워가 쳐다봐야하는 과거 타워의 위치다 (오른쪽에서 왼쪽으로)
    # 과거의 타워는 최대 N개까지 쌓일 수 있으므로, 명시적이지 않은 횟수(for 구문을 사용하지 않는게 좋다)
    # 따라서 여러 번 빼야할 수 있다 -> While이 들어가야하는 위치
    
    # 현재 타워의 높이가 이전 타워보다 높다면 -> 이전 타워는 애초에 신호를 수신받을 수 없으니 지워져야한다
    # 이전 타워는 1,2,3으로 추가되도 빛의 진행방향은 오른쪽에서 왼쪽이므로 3,2,1 순으로 빠질 것이다 (스택을 사용해야하는 이유)
    
     # and 조건으로 range out of index 문제도 피해갈 수 있다(영리한 풀이)
    while stack and heights[i] > heights[stack[-1]]:
        stack.pop()
    
    # 문제 풀이 방법 2    
    # 만약 현재 탑의 높이보다 낮은 탑들을 while을 통해 계속 빼냈는데도 탑이 남아있다면
    # 반드시 지금 탑보다는 높이가 높은 것이므로, 신호를 수신받을 수 있다
    # 그렇다면 정답(answer)에 들어가야한다
    
    # 현재 스택안이 비어있지 않다면
    if stack:
        # 0번째 탑이라는 개념은 없으니까 숫자 + 1
        answer[i] = stack[-1] + 1
    
    # 현재 탑은 어차피 다음 탑의 비교대상이 되어야하기 때문에 마지막으로 현재 탑의 위치를 스택에 넣어준다
    stack.append(i)

# answer를 출력
print(*answer, end = ' ')